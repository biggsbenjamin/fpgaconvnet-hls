# Module Testing 

To run a module test, use the `run_test.sh` script using the following arguments:

```
run_test.sh [-m (module)] [-n (test number)] [-c,-s,-e,-i]
```

The final flags correspond to the following:
 - `-c` = C simulation
 - `-s` = Synthesis
 - `-e` = Co-simulation
 - `-i` = Implementation

To run c-simulation for the 0th test if the __fork__ module for example, you would run `./run_test.sh -m fork -n 0 -c`.

For more details on what the `run_test.sh` script is calling, look at the `scripts/run_hls.tcl` script, which Vivado HLS calls.

The general file structure for each module test is as follows:

```bash
module/
├── config
│   └── config_n.json     # file containing parameters for test n
├── data
│   └── test_n
│       └── data.yaml     # data generated by gen_data.py script for the HLS testbench
├── module_test_prj/
├── gen_data.py           # generates data.yaml file from config_n.json
├── rpt
│   └── test_n.json       # a report generated which gives usage and performance for module
├── src
│   └── module.cpp        # main DUT file, where the module is called
└── tb
    ├── module_param.hpp  # header file containing config_n.json parameters as C++ macros
    ├── module_tb.cpp     # module testbench
    └── module_tb.hpp     # header file for DUT and testbench
```

For each module, a functional model is needed to generate reference test data. These models can be found in the `models/modules/` folder. The `gen_data.py` script calls this model for the given parameters.

The data is then loaded into the testbench using the `load_data` function from the `include/common_tb.cpp` folder. This function is overloaded for data of different dimensionality. This is then converted to a hls stream using the `to_stream` function.

 > **_NOTE:_**  The `load_data` is where the yaml-cpp dependency comes from

In terms of calling the DUT, currently several macros need to be defined in order to call the function with constant parameters. The general layout of the `src/module.cpp` file is as such:

```cpp
#include "module_tb.hpp"

#define MODULE_NAME MODULE
#define name        test
#include "module.hpp"

void module_top(stream_t(data_t) &in, stream_t(data_t) &out) {
    #pragma HLS DATAFLOW
    test_module(in,out);
}

#undef MODULE_NAME
#undef name
```

The `MODULE_NAME` and `name` must be defined prior to including the module. The `MODULE_NAME` macro is a prefix for all parameters defined in the `module_param.hpp` header file. The `name` macro is used to identify the instance of the module (in this case `test_module`). It is important to undefine these macros after the module is instantiated to avoid conflicting names.


